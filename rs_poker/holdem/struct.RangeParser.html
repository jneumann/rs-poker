<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `RangeParser` struct in crate `rs_poker`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, RangeParser">

    <title>rs_poker::holdem::RangeParser - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../normalize.css">
    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc struct">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Struct RangeParser</p><div class="block items"><ul><li><a href="#methods">Methods</a></li></ul></div><p class='location'><a href='../index.html'>rs_poker</a>::<wbr><a href='index.html'>holdem</a></p><script>window.sidebarCurrent = {name: 'RangeParser', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>rs_poker</a>::<wbr><a href='index.html'>holdem</a>::<wbr><a class="struct" href=''>RangeParser</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../../src/rs_poker/holdem/parse.rs.html#210' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct RangeParser;</pre><div class='docblock'><p>Unit struct to provide starting hand parse functions. Use this to parse things
like <code>RangeParser::parse_one(&quot;AKo&quot;)</code> and <code>RangeParser::parse_one(&quot;TT+&quot;)</code></p>
</div>
                    <h2 id='methods' class='small-section-header'>
                      Methods<a href='#methods' class='anchor'></a>
                    </h2>
                <h3 id='impl' class='impl'><span class='in-band'><code>impl <a class="struct" href="../../rs_poker/holdem/struct.RangeParser.html" title="struct rs_poker::holdem::RangeParser">RangeParser</a></code><a href='#impl' class='anchor'></a></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/rs_poker/holdem/parse.rs.html#212-525' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.parse_one' class="method"><span id='parse_one.v' class='invisible'><code>pub fn <a href='#method.parse_one' class='fnname'>parse_one</a>(r_str: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../rs_poker/core/struct.Hand.html" title="struct rs_poker::core::Hand">Hand</a>&gt;, <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../../src/rs_poker/holdem/parse.rs.html#357-524' title='goto source code'>[src]</a></span></h4>
<div class='docblock'><p>Parse a string and return all the starting hands</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>You can send in hands where the suits are specified for all hands.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;

<span class="kw">let</span> <span class="ident">hand</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AhKh&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">1</span>, <span class="ident">hand</span>.<span class="ident">len</span>());</pre>

<p>You can also specify hands were the suits are not specified,
but you want them to be suited.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AKs&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hands</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">4</span>);
<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">suit</span> <span class="op">==</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">suit</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Value</span>::<span class="ident">Ace</span>, <span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Value</span>::<span class="ident">King</span>, <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
}</pre>

<p>You can also specify that the cards are not of the same suit.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AKo&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">suit</span> <span class="op">!=</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">suit</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Value</span>::<span class="ident">Ace</span>, <span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">Value</span>::<span class="ident">King</span>, <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
}</pre>

<p>You can also use the + modifier after a set of
starting cards. The modifier will mean different things
for different sets of cards.</p>

<p>If the starting cards are pairs then the + means all pairs
equal to or above the specified values.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;TT+&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">==</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Ten</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Ten</span>);
}</pre>

<p>If the cards are connectors then the plus means all
connectors where the cards are above the specified
values.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;T9o+&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span>, <span class="ident">Value</span>::<span class="ident">from_u8</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="kw">as</span> <span class="ident">u8</span> <span class="op">+</span> <span class="number">1</span>));
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">suit</span> <span class="op">!=</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">suit</span>);
}</pre>

<p>If the cards are not paired and not connectors then plus
after the hand means all hands where the second card
is greater than or equal to the specified second card,
and below the first card.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;
<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;A9s+&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&gt;</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Nine</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">suit</span> <span class="op">==</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">suit</span>);
}</pre>

<p>It&#39;s also possible to do more complex ranges using
dash modifer. For example if you wanted to represent
Suited middle connectors you could do something like this.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">core</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;JT-67s&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">for</span> <span class="ident">hand</span> <span class="kw">in</span> <span class="ident">hands</span> {
    <span class="comment">// The largest card is always the first</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&gt;</span> <span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>);
    <span class="comment">// first card is great or equal to seven</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Seven</span>);
    <span class="comment">// Second card is greater or equal to six</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="op">&gt;=</span> <span class="ident">Value</span>::<span class="ident">Six</span>);
    <span class="comment">// First card is less than or equal to Jack</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span> <span class="op">&lt;=</span> <span class="ident">Value</span>::<span class="ident">Jack</span>);
    <span class="comment">// Second card is less than or equal to Ten</span>
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span> <span class="op">&lt;=</span> <span class="ident">Value</span>::<span class="ident">Ten</span>);
    <span class="comment">// All hands are connectors.</span>
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">1</span>, <span class="ident">hand</span>[<span class="number">0</span>].<span class="ident">value</span>.<span class="ident">gap</span>(<span class="kw-2">&amp;</span><span class="ident">hand</span>[<span class="number">1</span>].<span class="ident">value</span>));
}</pre>

<p>Also with the dash modifier there&#39;s no need to only have
connected cards. It&#39;s possible to represent ranges with gappers.
For example if you wanted to do high one gappers.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AQ-J9&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hands = {:?}&quot;</span>, <span class="ident">hands</span>);</pre>

<p>Since the dash modifier represents a range the difference
between cards ( the gap ) must remain constant.
If it&#39;s not parse_one will return an <code>Err</code>.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rs_poker</span>::<span class="ident">holdem</span>::<span class="ident">RangeParser</span>;
<span class="comment">// This will not work since the difference between Ace and King is one</span>
<span class="comment">// while the diffence between Jack and Nine is two.</span>
<span class="kw">let</span> <span class="ident">hands</span> <span class="op">=</span> <span class="ident">RangeParser</span>::<span class="ident">parse_one</span>(<span class="string">&quot;AK-J9&quot;</span>).<span class="ident">unwrap</span>();
<span class="comment">// We&#39;ll never get here</span>
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Hands = {:?}&quot;</span>, <span class="ident">hands</span>);</pre>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "rs_poker";
    </script>
    <script src="../../main.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>